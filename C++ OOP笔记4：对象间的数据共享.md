# C++ OOP笔记4：通过 static 实现对象间的数据共享；对象指针

> 本文全部内容基于西安电子科技大学潘蓉老师的《面向对象程序设计》课程记录而成。更多其他技术类内容可关注我的掘金和知乎： https://juejin.cn/user/1996368848621319/posts、[李经纬 - 知乎 (zhihu.com)](https://www.zhihu.com/people/li-jing-wei-78/posts)
>
> 有其他意见和建议欢迎联系，QQ：1428319077

## 静态成员

同一个类的不同对象，可以访问相同的静态成员变量、静态成员函数。

与静态成员相对的，非静态成员又被称为**实例属性**，它们的值是每个对象所特有的。

用static关键字声明的静态成员的属性则是被所有同类对象共有的**类属性**。

**静态成员不会在每个对象内部占用空间。**其空间在程序编译时进行分配，在整个程序中只存在唯一的地址（独立于任何对象），由所有对象共享访问。生命周期与程序本身相同。

静态成员可以在类不实例化的情况下进行访问。

```cpp
static int a;			// 这么声明就ok了
```



#### 静态成员的初始化

静态成员**只能在类体外**初始化。

但是可以在类的函数中（包括构造器等）进行重新赋值等。

```cpp
class Student {
	...
	static int stuNumber;	// 某类东西的数量，这种东西值得各个对象共享
	...
};
...
int Student::stuNumber = 0;	// 需要指出类型，不能加 static
```

#### 静态成员的使用

类的函数可以直接访问，无需指明使用哪一个（即无需作用域说明）

在类外访问，必须使用成员访问运算符（.）或作用域运算符（::）

```cpp
cout<<Student::stuNumber;	// 没有实例也可以用
cout<<stu1.stuNumber;		// 这样也行
```

#### 静态成员可以有权限限制

只有 public 的才可以在类外直接访问



### 静态成员函数

即，加了 static 声明出来的函数。其可以处理静态数据成员，但不能直接访问非静态成员。

如果想要访问非静态成员，需要通过参数传递方式得到对象名，然后通过对象名访问该对象的动态成员。

没有 this 指针。

```cpp
// 访问非静态成员
class Student {
	static void showInfo(Student stu) {
		cout<<a<<stu.b;		// 静态的直接引用，非静态的需要加上对象名
	}
	static int a;
	int b;
};

int main() {
	Student stu1;
	...
	Student::showInfo(stu1);	// 这样把一个对象传过去就能访问了
	...
}
```



## 对象指针

对象指针，指向对象所在内存的起始地址。

```
<类名> *<对象指针名> = &<对象名>;	 // 声明和初始化赋值。与普通指针相同
<指针名> -> <public成员名>;		// 访问
(*<对象指针名>).<public成员名>	   // 访问
```



用对象指针作为参数

```cpp
Student inputInfo(Student *stu) {
	string name;
	cin>>name;
	stu->name = name;
	return *stu;	// 返回指针所指向的对象
}
```

